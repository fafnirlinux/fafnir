#!/bin/sh

memory=1G

init() {
	get_nya
	build_nya

	if [[ ! -f nya ]]; then
		echo "couldn't build nya"
		exit 1
	fi

	clone_repo
}

get_nya() {
	[[ -f nya ]] && rm nya
	[[ -d nya_src ]] && rm -rf nya_src

	git clone https://github.com/fafnirlinux/nya nya_src

	if [[ ! -d nya_src ]]; then
		echo "couldn't clone nya"
	fi
}

build_nya() {
	if [[ ! -d nya_src ]]; then
		echo "nya source doesn't exist"
		exit 1
	fi

	cd nya_src
	mkdir -p build
	cd build
	cmake ..
	make -j$(nproc)
	cp nya ../../
	cd ../../
}

clone_repo() {
	mkdir -p src
	cd src

	[[ -d pkg ]] && rm -rf pkg

	git clone https://github.com/fafnirlinux/repo pkg

	if [[ ! -d pkg ]]; then
		echo "couldn't clone repo"
		exit 1
	fi

	[[ -d stuff ]] && rm -rf stuff
	mv pkg/stuff .
	cd ..
}

build_stage0() {
	mkdir -p rootfs tools

	[[ ! -f built.stage0 ]] && touch built.stage0

	emerge() {
		grep -Fxq $1 built.stage0 && return 0
		./nya build --config config.stage0
		ret=$?
		if (( $ret == 0 )); then
			echo $1 >> built.stage0
		fi
		return $ret
	}

	emerge musl

	return 1

	emerge musl-headers || return 1
	emerge binutils || return 1
	emerge gcc || return 1
	emerge musl || return 1
	emerge libgcc-shared || return 1
	emerge linux-headers || return 1
	emerge pkgconf || return 1
}

build_stage1() {
	if [[ ! -f built.stage0 ]]; then
		echo "build stage0 first."
		return 1
	fi

	if (( $(cat -n built.stage0 | wc -l ) != $(ls pkgs.stage0 | wc -l) )); then
		echo "build stage0 correctly."
		return 1
	fi

	[[ ! -f built.stage1 ]] && touch built.stage1

	emerge() {
		grep -Fxq $1 built.stage1 && return 0
		./nya build --config config.stage1 $1
		ret=$?
		if (( $ret == 0 )); then
			echo $1 >> built.stage1
		fi
		return $ret
	}

	emerge m4 || return 1
	emerge ncurses || return 1
	emerge bash || return 1
	emerge busybox || return 1
	emerge diffutils || return 1
	emerge file || return 1
	emerge gawk || return 1
	emerge grep || return 1
	emerge gzip || return 1
	emerge make || return 1
	emerge patch || return 1
	emerge sed || return 1
	emerge tar || return 1
	emerge xz || return 1
	emerge zlib || return 1
	emerge libarchive || return 1
	emerge curl || return 1
	emerge nya || return 1
	emerge binutils || return 1
	emerge gcc || return 1
}

prepare_rootfs() {
	mkdir -p rootfs/{dev,proc,sys,run}

	mknod -m 600 rootfs/dev/console c 5 1
	mknod -m 666 rootfs/dev/null c 1 3

	chown -R root:root rootfs/lib64
}

create_fs() {
	check_root

	./nya build filesystem
}

run() {
	if [[ ! -f fafnirlinux.iso ]]; then
		exit 1
	fi

	qemu-system-x86_64 -boot d -cdrom fafnirlinux.iso -m $memory
}

boot() {
	qemu-system-x86_64 -s -kernel iso/kernel -boot c -m $memory -hda iso/rootfs.gz -append "ro root=/dev/sr0"
}

iso() {
	if [[ ! -d rootfs ]]; then
		exit 1
	fi

	check_root

	mkdir -p iso
	cd rootfs

	[[ -f ../iso/rootfs.gz ]] && rm ../iso/rootfs.gz

	find . | cpio -R root:root -H newc -o | gzip > ../iso/rootfs.gz

	cd ..

	cp syslinux/isolinux.bin iso
	cp syslinux/isohdpfx.bin iso
	cp syslinux/ldlinux.c32 iso

	[[ ! -f iso/isolinux.cfg ]] && echo "default kernel initrd=rootfs.zst" > iso/isolinux.cfg

	cd iso

	xorriso \
		-as mkisofs \
		-o ../fafnirlinux.iso \
		-b isolinux.bin \
		-isohybrid-mbr isohdpfx.bin \
		-c boot.cat \
		-no-emul-boot \
		-boot-load-size 4 \
		-boot-info-table \
		./

	cd ..
}

check_root() {
	if [ "$EUID" -ne 0 ]; then
		echo "run as root"
		exit 1
	fi
}

enter_chroot() {
	sudo chroot rootfs $1
}

help() {
	echo idiot
}

main() {
	export STAGE=0

	case $1 in
		init) init ;;
		stage0) build_stage0 ;;
		stage1) build_stage1 ;;
		get-nya) get_nya ;;
		build-nya) build_nya ;;
		repo) clone_repo ;;
		chroot) shift; enter_chroot $1 ;;
		iso) iso ;;
		run) run ;;
		boot) boot ;;
		root) create_fs ;;
		build) shift; ./nya build $@ ;;
		install) shift; ./nya install $@ ;;
		remove) shift; ./nya remove $@ ;;
		*) emerge $@ ;;
	esac

	shift $((OPTIND -1))
}

main $@
